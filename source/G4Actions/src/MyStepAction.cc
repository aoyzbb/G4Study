//*********************************************
//  This is auto generated by G4gen 0.6
//                                  author:Qian

#include "G4Step.hh"
#include "G4RunManager.hh"
#include "G4LogicalVolume.hh"

#include "MyStepAction.hh"
#include "MyEvtAction.hh"
#include "MyDetectorConstruction.hh"
#include "TH1F.h"
//#include "g4root.hh"
#include "MyAnalysisManager.hh"
#include "Verbose.hh"

MyStepAction::MyStepAction(MyEvtAction *evtAction)
    : G4UserSteppingAction(),
      fMyEvtAction(evtAction)
{
    if (verbose)
        G4cout << "====>MyStepAction::MyStepAction()" << G4endl;

    //low QE
    fQE = new TH1F("fQE", "fQE", 20, 120, 220);
    double QE[20] = {49., 67., 62., 52., 43., 36., 30., 25., 19., 15., 14., 12., 9., 8., 5., 3., 2., 0., 0., 0.};
    for (int i = 0; i < 20; i++)
        fQE->SetBinContent(i + 1, QE[i]);

    ////high QE
    //fQE = new TH1F("fQE", "fQE", 14, 150, 220);
    //double QE[14] = {45., 40., 35., 32., 29., 27., 22., 20., 14., 9., 4., 2., 0.1, 0.0};
    //for (int i = 0; i < 14; i++)
    //    fQE->SetBinContent(i + 1, QE[i]);
}

MyStepAction::~MyStepAction()
{
}

void MyStepAction::UserSteppingAction(const G4Step *aStep)
{
    //if (verbose)
    //    G4cout << "====>MyStepAction::UserSteppingAction()" << G4endl;

    MyAnalysisManager::GetInstance()->SteppingAction(aStep);
    
    
    
    ////入射粒子击中RICH的入射信息，保存包括入射角，旋转矩阵等信息
    //if (parentID == 0)
    //{
    //    auto *pVolume = postStepPoint->GetTouchableHandle()->GetVolume();
    //    if (pVolume == NULL)
    //        return;

    //    G4LogicalVolume *presentVolume = pVolume->GetLogicalVolume();
    //    if (presentVolume->GetName().compare(0, 9, "QuartzBox") != 0) //要求当前step位于"QuartzBoxVol"
    //        return;

    //    G4LogicalVolume *prestepVolume = preStepPoint->GetTouchableHandle()->GetVolume()->GetLogicalVolume();
    //    if (prestepVolume->GetName().compare(0, 4, "RICH") != 0) //要求前一step位于"RICH"
    //        return;

    //    const G4VTouchable *touchable = postStepPoint->GetTouchable();
    //    const G4RotationMatrix *rotation = touchable->GetRotation();
    //    G4RotationMatrix rotation_inv = rotation->inverse();
    //    G4ThreeVector translation = touchable->GetTranslation();
    //    G4VSolid *sector = touchable->GetSolid();

    //    G4ThreeVector posLocal = *rotation * (postPos - translation);
    //    G4ThreeVector normal = rotation_inv * (-sector->SurfaceNormal(posLocal)); //ERROR! 都是一样的？？？

    //    G4ThreeVector trackDirectionLocal = *rotation * postMom;

    //    G4double incidenceAngle = acos(normal.dot(trackDirectionLocal));

    //    SimEvent *fSimEvent = MyAnalysisManager::GetInstance()->GetSimEvent();
    //    fSimEvent->SetHitInfo(postPos, postMom, *rotation, translation, normal, incidenceAngle);
    //}

    ////保存入射粒子产生的切伦科夫光子信息
    //if (parentID == 1 && pdgID == 0)
    //{
    //    G4String proName = aTrack->GetCreatorProcess()->GetProcessName();
    //    if (proName != "Cerenkov")
    //        return;

    //    auto *pVolume = postStepPoint->GetTouchableHandle()->GetVolume();
    //    if (pVolume == NULL)
    //        return;

    //    G4LogicalVolume *presentVolume = pVolume->GetLogicalVolume();
    //    if (presentVolume->GetName() != "FR4BoxVol")
    //        return;

    //    G4double optEng = 0.0012398 / aTrack->GetKineticEnergy(); //convert to [nm]
    //    //G4double optX = postPos.x();
    //    //G4double optY = postPos.y();
    //    //G4double optZ = postPos.z();

    //    double qe = fQE->Interpolate(optEng) / 100.;
    //    if (G4UniformRand() > qe)
    //        return;

    //    SimEvent *fSimEvent = MyAnalysisManager::GetInstance()->GetSimEvent();
    //    fSimEvent->StoreHit(postPos, optEng);

    //    /*
    //    auto analysisManager = G4AnalysisManager::Instance();
    //    analysisManager->FillNtupleDColumn(0, 0, optEng);
    //    analysisManager->FillNtupleDColumn(0, 1, optX);
    //    analysisManager->FillNtupleDColumn(0, 2, optY);
    //    analysisManager->FillNtupleDColumn(0, 3, optZ);
    //    analysisManager->FillNtupleDColumn(0, 4, aTrack->GetVertexPosition().x());
    //    analysisManager->FillNtupleDColumn(0, 5, aTrack->GetVertexPosition().y());
    //    analysisManager->FillNtupleDColumn(0, 6, aTrack->GetVertexPosition().z());
    //    analysisManager->AddNtupleRow(0);
    //    */
    //}
    //else
    //{
    //    return;
    //    
    //    //带电粒子击中计数
    //    auto *pVolume = postStepPoint->GetTouchableHandle()->GetVolume();
    //    if (pVolume == NULL)
    //        return;

    //    G4LogicalVolume *presentVolume = pVolume->GetLogicalVolume();
    //    if (presentVolume->GetName() != "FR4BoxVol")
    //        return;

    //    if (!aStep->IsFirstStepInVolume())
    //        return;
 
    //    G4String proName = postStepPoint->GetProcessDefinedStep()->GetProcessName();
    //    if (proName != "eIoni")
    //        return;
    //    
    //    /*
    //    auto analysisManager = G4AnalysisManager::Instance();
    //    analysisManager->FillNtupleDColumn(2, 0, postPos.x());
    //    analysisManager->FillNtupleDColumn(2, 1, postPos.y());
    //    analysisManager->FillNtupleDColumn(2, 2, postPos.z());
    //    analysisManager->FillNtupleDColumn(2, 3, aTrack->GetVertexPosition().x());
    //    analysisManager->FillNtupleDColumn(2, 4, aTrack->GetVertexPosition().y());
    //    analysisManager->FillNtupleDColumn(2, 5, aTrack->GetVertexPosition().z());
    //    analysisManager->AddNtupleRow(2);
    //    */
    //}
    
}